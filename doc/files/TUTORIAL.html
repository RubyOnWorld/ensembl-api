<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: TUTORIAL</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>TUTORIAL</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>TUTORIAL
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Sep 11 15:36:08 +0100 2007</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Ruby <a href="../classes/Ensembl.html">Ensembl</a> Core API tutorial</h1>
<p>
By Jan Aerts. Copy-paste-modified from the excellent perl API tutorial at
<a
href="http://www.ensembl.org/info/software/core/core_tutorial.html">www.ensembl.org/info/software/core/core_tutorial.html</a>
(with permission of the core <a href="../classes/Ensembl.html">Ensembl</a>
team).
</p>
<p>
Based on release 45.
</p>
<h2>Introduction</h2>
<p>
This tutorial describes how to use the <a
href="../classes/Ensembl.html">Ensembl</a> Core Ruby API. It is intended to
be an introduction and demonstration of the general API concepts. This
tutorial is not comprehensive, but it will hopefully enable to reader to
become quickly productive, and facilitate a rapid understanding of the core
system. This tutorial assumes at least some familiarity with Ruby.
</p>
<p>
The Ruby API provides a level of abstraction over the <a
href="../classes/Ensembl.html">Ensembl</a> Core databases. To external
users the API may be useful to automate the extraction of particular data.
As a brief introduction this tutorial focuses primarily on the retrieval of
data from the <a href="../classes/Ensembl.html">Ensembl</a> Core databases.
</p>
<p>
The Ruby API is only one of many ways of accessing the data stored in <a
href="../classes/Ensembl.html">Ensembl</a>. Additionally there is a genome
browser web interface, and the BioMart system. BioMart may be a more
appropriate tool for certain types of data mining.
</p>
<p>
This API is for read-only querying of the database.
</p>
<h2>Other sources of information</h2>
<p>
The <a href="../classes/Ensembl.html">Ensembl</a> Core API has a decent set
of code documentation in the form of standard Ruby RDOC. This is
documentation is mixed in with the actual code, but can be automatically
extracted and formatted using some software tools. One version of this
documentation is available at the website you&#8216;re looking at.
</p>
<p>
If you have your RUBYLIB environment variable set correctly, you can use
the command ri. For example the following command will bring up some
documentation about the Slice class and each of its methods:
</p>
<pre>
  ri Ensembl::Core::Slice
</pre>
<p>
For additional information you can contact Jan Aerts
(jan.aerts@bbsrc.ac.uk) or preferably send an email to the bioruby mailing
list (see <a href="http://www.bioruby.org">www.bioruby.org</a>).
</p>
<h2>Obtaining and installing the code</h2>
<p>
The <a href="../classes/Ensembl.html">Ensembl</a> Ruby API is made
available through a public CVS server. The instructions for how to install
the code is available at <a
href="http://rubyforge.org/projects/bioruby-annex">rubyforge.org/projects/bioruby-annex</a>/.
The easiest way is to install using rubygems: download the ensembl_api.gem
file from the rubyforge website and run
</p>
<pre>
  gem install ensembl_api.gem
</pre>
<h2>Code conventions</h2>
<p>
Several naming conventions are used throughout the API. Learning these
conventions will aid in your understanding of the code.
</p>
<p>
Variable names are underscore-separated all lower-case words.
</p>
<pre>
  slice_1
  exon_1
  gene_a
</pre>
<p>
Class and package names are CamelCase words that begin with capital
letters.
</p>
<pre>
  Ensembl::Core::Gene
  Ensembl::Core::Exon
  Ensembl::Core::CoordSystem
  Ensembl::Core::SeqRegion
</pre>
<p>
Method names are entirely lower-case, underscore separated words. Methods
are called on an object or class by appending a period to that object or
class and adding the method name.
</p>
<pre>
  Ensembl::Core::Slice.genes
  transcript_a.five_prime_utr_seq
</pre>
<p>
Class methods are responsible for the creation of various objects. Most of
this is standard ActiveRecord behaviour and will be discussed below.
</p>
<h2>ActiveRecord</h2>
<p>
Most of the API is based on ActiveRecord to get data from that database. In
general, each table is described by a class with the same name: the
coord_system table is covered by the <a
href="../classes/Ensembl/Core/CoordSystem.html">Ensembl::Core::CoordSystem</a>
class, the seq_region table is covered by the <a
href="../classes/Ensembl/Core/SeqRegion.html">Ensembl::Core::SeqRegion</a>
class, etc. As a result, accessors are available for all columns in each
table. For example, the seq_region table has the following columns:
seq_region_id, name, coord_system_id and length. Through ActiveRecord,
these column names become available as attributes of <a
href="../classes/Ensembl/Core/SeqRegion.html">Ensembl::Core::SeqRegion</a>
objects:
</p>
<pre>
  puts my_seq_region.seq_region_id
  puts my_seq_region.name
  puts my_seq_region.coord_system_id
  puts my_seq_region.length.to_s
</pre>
<p>
ActiveRecord makes it easy to extract data from those tables using the
collection of find methods. There are three types of find methods (e.g. for
the <a
href="../classes/Ensembl/Core/CoordSystem.html">Ensembl::Core::CoordSystem</a>
class):
</p>
<ul>
<li>find based on primary key in table:

<pre>
  my_coord_system = CoordSystem.find(5)
</pre>
</li>
<li>find_by_sql:

<pre>
  my_coord_system = CoordSystem.find_by_sql('SELECT * FROM coord_system WHERE name = 'chromosome'&quot;)
</pre>
</li>
<li>find_by_&lt;insert_your_column_name_here&gt;

<pre>
  my_coord_system1 = CoordSystem.find_by_name('chromosome')
  my_coord_system2 = CoordSystem.find_by_rank(3)
</pre>
</li>
</ul>
<p>
To find out which find_by_&lt;column&gt; methods are available, you can
list the column names using the column_names class methods:
</p>
<pre>
 puts Ensembl::Core::CoordSystem.column_names.join(&quot;\t&quot;)
</pre>
<p>
For more information on the find methods, see
ar.rubyonrails.org/classes/ActiveRecord/Base.html#M000344
</p>
<p>
The relationships between different tables are accessible through the
classes as well. For example, to loop over all seq_regions belonging to a
coord_system (a coord_system &quot;has many&quot; seq_regions):
</p>
<pre>
  chr_coord_system = CoordSystem.find_by_name('chromosome')
  chr_coord_system.seq_regions.each do |seq_region|
    puts seq_region.name
  end
</pre>
<p>
Of course, you can go the other way as well (a seq_region &quot;belongs
to&quot; a coord_system):
</p>
<pre>
  chr4 = SeqRegion.find_by_name('4')
  puts chr4.coord_system.name  #--&gt; 'chromosome'
</pre>
<p>
To find out what relationships exist for a given class, you can use the
reflect_on_all_associations class methods:
</p>
<pre>
  puts SeqRegion.reflect_on_all_associations(:has_many).collect{|a| a.name.to_s}.join(&quot;\n&quot;)
  puts SeqRegion.reflect_on_all_associations(:has_one).collect{|a| a.name.to_s}.join(&quot;\n&quot;)
  puts SeqRegion.reflect_on_all_associations(:belongs_to).collect{|a| a.name.to_s}.join(&quot;\n&quot;)
</pre>
<h2>Connecting to the <a href="../classes/Ensembl.html">Ensembl</a> database and a minimal script</h2>
<p>
All data used and created by <a href="../classes/Ensembl.html">Ensembl</a>
is stored in MySQL relational databases. If you want to access this
database the first thing you have to do is to connect to it. This is done
behind the scenes using the ActiveRecord module.
</p>
<p>
First, we need to tell our computer where they can find the API code. This
information is contained in the RUBYLIB environment variable. Suppose you
have save the API in /usr/local/lib/ruby/ensembl-api (with subdirectories
lib/, test/, samples/, &#8230;), you could set the environment variable on
a bash shell like this:
</p>
<pre>
  export RUBYLIB=$RUBYLIB:/usr/local/lib/ruby/ensembl-api/lib
</pre>
<p>
Next, we need to import all Ruby modules that we will be using. Every <a
href="../classes/Ensembl.html">Ensembl</a> script that you will write will
contain a use statement like the following:
</p>
<pre>
  require 'ensembl'
</pre>
<p>
Alternatively, if you installed the API as a gem, you would write:
</p>
<pre>
  require 'rubygems'
  require_gem 'ensembl-api'
</pre>
<p>
<a href="../classes/Ensembl.html">Ensembl</a> stores its data in a separate
database for each species and each release of that species. The Ruby <a
href="../classes/Ensembl.html">Ensembl</a> API does a lot automatically, so
you only have to know the species name to connect to the release 45 version
of its core database. This name should be provided in snake_case (all
lowercase connected by underscore):
</p>
<pre>
  Ensembl::Core::CoreDBConnection.connect('homo_sapiens')
</pre>
<p>
With the connection established, you&#8216;ll be able to get objects from
the database, e.g.
</p>
<pre>
  chromosome_4 = Ensembl::Core::SeqRegion.find_by_name('4')
</pre>
<p>
You have to include the &#8216;<a
href="../classes/Ensembl/Core.html">Ensembl::Core</a>::&#8217; bit to every
call to a class. However, if you include the line
</p>
<pre>
  include Ensembl::Core
</pre>
<p>
just after you &quot;require &#8216;ensembl&#8217;&quot;, you don&#8216;t
have to anymore. The rest of this tutorial expects you to have done the
include command. So a very short but complete ruby script could look like
this:
</p>
<pre>
  require 'ensembl'
  include Ensembl::Core
  CoreDBConnection.connect('homo_sapiens')
  chromosome_4 = SeqRegion.find_by_name('4')
  puts chromosome_4.name
</pre>
<h2>Slices</h2>
<p>
A Slice object represents a single continuous region of a genome. Slices
can be used to obtain sequence, features or other information from a
particular region of interest. There are several ways to obtain a slice,
but we will start with the Ensembl::Core::Slice#fetch_by_region method
which is the most commonly used. This class method takes numerous arguments
but most of them are optional. In order, the arguments are:
coord_system_name, seq_region_name, start, end, strand,
coord_system_version. The following are several examples of how to use the
Ensembl::Core::Slice#fetch_by_region method:
</p>
<ul>
<li>Obtain a slice covering the entire chromosome X

<pre>
  slice = Slice.fetch_by_region('chromosome', 'X')
</pre>
</li>
<li>Obtain a slice covering the entire clone AL359765.6

<pre>
  slice = Slice.fetch_by_region('clone', 'AL359765.6')
</pre>
</li>
<li>Obtain a slice covering an entire NT contig

<pre>
  slice = Slice.fetch_by_region('supercontig', 'NT_011333')
</pre>
</li>
<li>Obtain a slice covering the region from 1MB to 2MB (inclusively) of
chromosome 20

<pre>
  slice = Slice.fetch_by_region('chromosome', '20', 1000000, 2000000)
</pre>
</li>
</ul>
<p>
Another useful way to obtain a slice is with respect to a gene, e.g. with
5kb flanking sequence:
</p>
<pre>
    slice = Slice.fetch_by_gene_stable_id('ENSG00000099889', 5000)
</pre>
<p>
This will return a slice that contains the sequence of the gene specified
by its stable <a href="../classes/Ensembl.html">Ensembl</a> ID. It also
returns 5000bp of flanking sequence at both the 5&#8217; and 3&#8217; ends,
which is useful if you are interested in the environs that a gene inhabits.
You needn&#8216;t have the flanking sequence it you don&#8216;t want it
&#8212; in this case set the number of flanking bases to zero or simply
omit the second argument entirely. Note that the fetch_by_gene_stable_id()
method always returns a slice on the forward strand even if the gene is on
the reverse strand.
</p>
<p>
To retrieve a set of slices from a particular coordinate system the
fetch_all method can be used:
</p>
<ul>
<li>Retrieve slices of every chromosome in the database

<pre>
  slices = Slice.fetch_all('chromosome')
</pre>
</li>
<li>Retrieve slices of every BAC clone in the database

<pre>
  slices = Slice.fetch_all('clone')
</pre>
</li>
</ul>
<p>
For certain types of analysis it is necessary to break up regions into
smaller manageable pieces. The method Slice#split can be used to break up
larger slices into smaller component slices. The following code creates an
array of subslices of chromosome 1, with the (maximal) length of each slice
100000 bp and an overlap of 250 bp.
</p>
<pre>
  big_slice = Slice.fetch_by_region('chromosome', 1)
  subslices = big_slice.split(100000, 250)
</pre>
<p>
To obtain sequence from a slice the Slice#seq method can be used:
</p>
<pre>
  seq = slice.seq
  puts seq
</pre>
<p>
We can query the slice for information about itself:
</p>
<pre>
  seq_region = slice.seq_region.name
  coord_system = slice.seq_region.coord_system.name
  start = slice.start
  stop = slice.stop
  strand = slice.strand

  puts &quot;Slice: #{coord_system} #{seq_region} #{start}-#{stop} (#{strand})&quot;
</pre>
<p>
Many classes can provide a set of features which overlap a slice. The slice
itself also provides a means to obtain features which overlap its region.
To obtain a list of genes which overlap a slice:
</p>
<pre>
  slice_a = Slice.fetch_by_region('chromosome','X')
  genes = slice_a.genes
</pre>
<p>
<b>CAUTION</b>: The slice concept is a little bit different from that in
the perl API. If you ask a gene for its slice using the perl API, you get a
slice covering the <em>whole</em> of the chromosome. In contrast, the slice
created by the ruby API only contains that bit covered by the gene. The <a
href="../classes/Ensembl/Core/SeqRegion.html">Ensembl::Core::SeqRegion</a>
class is used to refer to whole things.
</p>
<h2>Features</h2>
<p>
Features are objects in the database which have a defined location on the
genome. All features in <a href="../classes/Ensembl.html">Ensembl</a>
include the <a
href="../classes/Ensembl/Core/Sliceable.html">Ensembl::Core::Sliceable</a>
mixin and have the following location defining attributes: start, end,
strand, slice.
</p>
<p>
All feature objects can be retrieved using their find method of their class
or any of the generic find_by_() methods (see the ActiveRecord bit of this
tutorial). The following example illustrates how Transcript features and
DnaDnaAlignFeature features can be obtained from the database. All features
in the database can be retrieved in similar ways from their own object
adaptors.
</p>
<ul>
<li>Get a slice of chromosome 20, 10MB-11MB

<pre>
  slice = Slice.fetch_by_region('chromosome', '20', 10000000, 11000000 )
</pre>
</li>
<li>Fetch all of the transcripts overlapping chromosome 20, 10MB-11MB

<pre>
  transcripts = slice.transcripts
  transcripts.each do |transcript|
    name = transcript.stable_id
    internal_id = transcript.id
    start = transcript.start
    stop = transcript.stop
    strand = transcript.strand

    puts &quot;Transcript #{name} [#{internal_id}] #{start}-#{stop} (#{strand})&quot;
  end
</pre>
</li>
<li>Fetch all of the DNA-DNA alignments overlapping chromosome 20, 10MB-11MB

<pre>
  dafs = slice.dna_align_features
  dafs.each do |daf|
    name = daf.hit_name
    internal_id = daf.id
    start = daf.start
    stop = daf.stop
    strand = daf.strand

    puts &quot;DNA alignment #{name} [#{internal_id}] #{start}-#{stop} (#{strand})&quot;
  end
</pre>
</li>
<li>Fetch a transcript by its internal identifier

<pre>
  transcript = Transcript.find(100)
</pre>
</li>
<li>Fetch a DnaAlignFeature by its internal identifiers

<pre>
  daf = DnaAlignFeature.find(100)
</pre>
</li>
</ul>
<p>
All features also have the transform method which are described in detail
in a later section of this tutorial.
</p>
<h3>Features across coordinate systems</h3>
<p>
In the <a href="../classes/Ensembl.html">Ensembl</a> database, some
features might be related to one coordinate system, while other features
are related to another one (for more information on coordinate systems, see
below). For example, there are three coordinate systems in cow: contigs,
scaffolds and chromosomes. Scaffold Chr4.003.122 does not have any
simple_features on it. However, the equivalent regions in the contig and
chromosome coordinate systems have 37 and 85 (=total of 122), respectively.
If you therefore ask that scaffold to list its simple_features, you
wouldn&#8216;t get any. A workaround for this, is to first create a slice
for this scaffold, and ask that <em>slice</em> for its simple_features.
</p>
<pre>
  scaffold = SeqRegion.find_by_name('Chr4.003.122')
  puts scaffold.simple_features.length #--&gt; 0
  slice = Slice.fetch_by_region('scaffold','Chr4.003.122')
  puts slice.simple_features.length    #--&gt; 122
</pre>
<p>
The reason this works, is that any retrieval for a slice also checks what
coordinate systems that type of feature is annotated on.
</p>
<h2>Genes, Transcripts, and Exons</h2>
<p>
Genes, exons and transcripts are also features and can be treated in the
same way as any other feature within <a
href="../classes/Ensembl.html">Ensembl</a>. A transcript in <a
href="../classes/Ensembl.html">Ensembl</a> is a grouping of exons. A gene
in <a href="../classes/Ensembl.html">Ensembl</a> is a grouping of
transcripts which share any overlapping (or partially overlapping) exons.
Transcripts also have an associated Translation object which defines the
UTR and CDS composition of the transcript. Introns are not defined
explicitly in the database but can be obtained by the
Ensembl::Core::Transcript#introns method (not implemented yet).
</p>
<p>
Important: like all <a href="../classes/Ensembl.html">Ensembl</a> features
the start of an exon is always less than or equal to the end of the exon,
regardless of the strand it is on. The start of the transcript is the start
of the first exon of a transcript on the forward strand or the start of the
last exon of a transcript on the reverse strand. The start and end of a
gene are defined to be the lowest start value of its transcripts and the
highest end value respectively.
</p>
<p>
Genes, translations, transcripts and exons all have stable identifiers.
These are identifiers that are assigned to <a
href="../classes/Ensembl.html">Ensembl</a>&#8216;s predictions, and
maintained in subsequent releases. For example, if a transcript (or a
sufficiently similar transcript) is re-predicted in a future release then
it will be assigned the same stable identifier as its predecessor.
</p>
<p>
The following is an example of the retrieval of a set of genes, transcripts
and exons:
</p>
<pre>
  slice = Slice.fetch_by_region('chromosome','X',1000000,10000000)
  puts slice.display_name

  slice.genes.each do |gene|
    puts &quot;\t&quot; + gene.stable_id

    gene.transcripts.each do |transcript|
      puts &quot;\t\t&quot; + transcript.stable_id

      transcript.exons.each do |exon|
        puts &quot;\t\t\t&quot; + exon.id.to_s
    end
  end
</pre>
<p>
In addition to the methods which are present on every feature, the
transcript class has many other methods which are commonly used. Several
methods can be used to obtain transcript related sequences. At the time of
writing this tutorial, these methods return strings rather than bioruby
Bio::Sequence objects. The following example demonstrates the use of some
of these methods:
</p>
<ul>
<li>The Ensembl::Core::Transcript#seq method returns the concatenation of the
exon sequences. This is the cDNA of the transcript:

<pre>
  puts &quot;cDNA: &quot; + transcript.seq
</pre>
</li>
<li>The Ensembl::Core::Transcript#cds_seq method returns only the CDS of the
transcript

<pre>
  puts &quot;CDS: &quot; + transcript.cds_seq
</pre>
</li>
<li>UTR sequences are obtained via the five_prime_utr_seq and
three_prime_utr_seq methods

<pre>
  fiv_utr = transcript.five_prime_utr_seq
  thr_utr = transcript.three_prime_utr_seq

  puts &quot;5' UTR: &quot; + ( fiv_utr.nil? ? 'None' : fiv_utr )
  puts &quot;3' UTR: &quot; + ( thr_utr.nil? ? 'None' : thr_utr )
</pre>
</li>
<li>The peptide sequence is obtained from the
Ensembl::Core::Transcript#protein_seq method. If the transcript is
non-coding, undef is returned.

<pre>
  peptide = transcript.protein_seq

  puts &quot;Translation: &quot; + ( peptide.nil? ? 'None' : peptide )
</pre>
</li>
</ul>
<h2>Translations and ProteinFeatures</h2>
<p>
Translation objects and peptide sequence can be extracted from a Transcript
object. It is important to remember that some <a
href="../classes/Ensembl.html">Ensembl</a> transcripts are non-coding
(pseudo-genes, ncRNAs, etc.) and have no translation. The primary purpose
of a Translation object is to define the CDS and UTRs of its associated
Transcript object. Peptide sequence is obtained directly from a Transcript
object not a Translation object as might be expected. The following example
obtains the peptide sequence of a <a
href="../classes/Ensembl/Core/Transcript.html">Ensembl::Core::Transcript</a>
and the <a
href="../classes/Ensembl/Core/Translation.html">Ensembl::Core::Translation</a>&#8216;s
stable identifier:
</p>
<pre>
  stable_id = 'ENST00000044768'

  transcript = Transcript.find_by_stable_id(stable_id)

  puts transcript.stable_id
  puts transcript.translation.stable_id
</pre>
<h2>PredictionTranscripts</h2>
<p>
PredictionTranscripts are the results of ab initio gene finding programs
that are stored in <a href="../classes/Ensembl.html">Ensembl</a>. Example
programs include Genscan and SNAP. Prediction transcripts have the same
interface as normal transcripts and thus they can be used in the same way.
</p>
<pre>
  prediction_transcripts = slice.prediction_transcripts
  prediction_transcripts.each do |pt|
    exons = pt.prediction_exons
    type = pt.analysis.logic_name

    puts &quot;#{type} prediction has #{exons.length.to_s} exons&quot;

    exons.each do |exon|
      puts exon.to_yaml
    end
  end
</pre>
<h2>Alignment Features</h2>
<p>
Two types of alignments are stored in the core <a
href="../classes/Ensembl.html">Ensembl</a> database: alignments of DNA
sequence to the genome and alignments of peptide sequence to the genome.
These can be retrieved as Ensembl::Core::DnaAlignFeatures and
Ensembl::Core::ProteinAlignFeatures respectively. A single gapped alignment
is represented by a single feature with a cigar line. A cigar line is a
compact representation of a gapped alignment as single string containing
letters M (match) D (deletion), and I (insertion) prefixed by integer
lengths (the number may be omitted if it is 1).
</p>
<p>
The following example shows the retrieval of some alignment features.
</p>
<ul>
<li>Retrieve dna-dna alignment features from the slice region

<pre>
  features = slice.dna_align_features('Vertrna')
  features.each do |f|
    puts f.to_yaml
  end
</pre>
</li>
<li>Retrieve protein-dna alignment features from the slice region

<pre>
  features = slice.protein_align_features('Swall')
  features.each do |f|
    puts f.to_yaml
  end
</pre>
</li>
</ul>
<h2>Repeats</h2>
<p>
Repetitive regions found by RepeatMasker and TRF (Tandem Repeat Finder) are
represented in the <a href="../classes/Ensembl.html">Ensembl</a> database
as RepeatFeatures. Short non-repetitive regions between repeats are found
by the program Dust and are also stored as RepeatFeatures. RepeatFeatures
can be retrieved and used in the same way as other <a
href="../classes/Ensembl.html">Ensembl</a> features.
</p>
<pre>
  repeats = slice.repeats
  repeats.each do |r|
    puts r.display_id + &quot;\t&quot; + repeat.start.to_s + &quot;\t&quot; + repeat.stop.to_s
  end
</pre>
<h2>Markers</h2>
<p>
Markers are imported into the <a href="../classes/Ensembl.html">Ensembl</a>
database from UniSTS and several other sources. A marker in <a
href="../classes/Ensembl.html">Ensembl</a> consists of a pair of primer
sequences, an expected product size and a set of associated identifiers
known as synonyms. Markers are placed on the genome electronically using an
analysis program such as ePCR and their genomic positions are retrievable
as MarkerFeatures. Map locations (genetic, radiation hybrid and in situ
hybridization) for markers obtained from actual experimental evidence are
also accessible.
</p>
<p>
Markers can be fetched by their name. The Marker#find_all_by_name returns
an array, and Marker#find_by_name returns the first element of that array,
i.e. a marker object.
</p>
<pre>
  marker = Marker.find_by_name('D9S1038E')
</pre>
<ul>
<li>Display the various names associated with the same marker

<pre>
  marker.marker_synonyms.each do |ms|
    if ms.source.nil?
      puts ms.name
    else
      puts ms.source + ':' + ms.name
    end
  end
</pre>
</li>
<li>Display the primer info

<pre>
  puts &quot;left primer: &quot; + marker.left_primer.to_s
  puts &quot;right primer: &quot; + marker.right_primer.to_s
  puts &quot;product size: &quot; + marker.min_primer_dist.to_s + '-' + marker.max_primer_dist.to_s
</pre>
</li>
<li>Display out genetic/RH/FISH map information

<pre>
  puts &quot;Map locations:&quot;
  marker.marker_map_locations.each do |mapping|
    puts mapping.map.map_name + &quot;\t&quot; + mapping.chromosome_name + &quot;\t&quot; + mapping.position.to_s
  end
</pre>
</li>
</ul>
<p>
MarkerFeatures, which represent genomic positions of markers, can be
retrieved and manipulated in the same way as other <a
href="../classes/Ensembl.html">Ensembl</a> features.
</p>
<ul>
<li>Obtain the positions for an already retrieved marker

<pre>
  marker.marker_features.each do |mf|
    puts mf.slice.display_name
  end
</pre>
</li>
<li>Retrieve all marker features in a given region

<pre>
  marker_features = slice.marker_features
  marker_features.each do |mf|
    puts mf.slice.display_name
  end
</pre>
</li>
</ul>
<h2>MiscFeatures</h2>
<p>
MiscFeatures are features with arbitrary attributes which are placed into
arbitrary groupings. MiscFeatures can be retrieved as any other feature and
are classified into distinct sets by a set code. Generally it only makes
sense to retrieve all features which have a particular set code because
very diverse types of MiscFeatures are stored in the database.
</p>
<p>
MiscFeature attributes are represented by Attribute objects and can be
retrieved via a get_all_Attributes() method.
</p>
<p>
The following example retrieves all MiscFeatures representing ENCODE
regions on a given slice and prints out their attributes:
</p>
<pre>
  encode_regions = slice.misc_features('encode')
  encode_regions.each do |er|
    attributes = er.misc_attribs
    attributes.each do |a|
      puts a.to_s
    end
  end
</pre>
<p>
This example retrieves all misc features representing a BAC clone via its
name and prints out their location and other information:
</p>
<pre>
  clones = MiscFeature.find_all_by_attribute_type_value('name', 'RP11-62N12')
  clones.each do |clone|
    slice = clone.slice
    puts slice.to_yaml

    attributes = clone.misc_attribs
    attributes.each do |a|
      puts a.to_s
    end
  end
</pre>
<h2>External References</h2>
<p>
<a href="../classes/Ensembl.html">Ensembl</a> cross references its genes,
transcripts and translations with identifiers from other databases. A cross
reference is referenced by a Xref object. The following code snippet
retrieves and prints Xrefs for a gene, its transcripts and its
translations:
</p>
<ul>
<li>Get the &#8216;COG6&#8217; gene from human

<pre>
  cog6 = Gene.find_by_name('COG6')
  puts 'GENE: ' + cog6.stable_id + &quot; (internal id: &quot; + cog6.id.to_s + &quot;)&quot;

  cog6.xrefs.each do |x|
    puts x.to_s
  end

  cog6.transcripts.each do |t|
    puts 'TRANSCRIPT: ' + t.stable_id
    t.xrefs.each do |x|
      puts &quot;\s\s&quot; + x.to_s
    end

    # Watch out: pseudogenes have no translation
    if ! t.translation.nil?
      translation = t.translation
      puts &quot;\tTRANSLATION: &quot; + translation.stable_id
      translation.xrefs.each do |x|
        puts &quot;\t\s\s&quot; + x.to_s
      end
    end
  end
</pre>
</li>
</ul>
<p>
Often it is useful to obtain all of the Xrefs associated with a gene and
its associated transcripts and translation as in the above example. As a
shortcut to calling xrefs on all of the above objects the Gene#all_xrefs
method can be used instead. The above example could be shortened by using
the following:
</p>
<pre>
  cog6.all_xrefs.each do |x|
    puts x.to_s
  end
</pre>
<p>
This returns all xrefs for the gene itself, including those for all
transcripts and translations.
</p>
<h2>Coordinates</h2>
<p>
We have already discussed the fact that slices and features have
coordinates, but we have not defined exactly what these coordinates mean.
</p>
<p>
<a href="../classes/Ensembl.html">Ensembl</a>, and many other
bioinformatics applications, use inclusive coordinates which start at 1.
The first nucleotide of a DNA sequence is 1 and the first amino acid of a
peptide sequence is also 1. The length of a sequence is defined as end -
start + 1.
</p>
<p>
In some rare cases inserts are specified with a start which is one greater
than the end. For example a feature with a start of 10 and an end of 9
would be a zero length feature between base pairs 9 and 10.
</p>
<p>
Slice coordinates are relative to the start of the underlying DNA sequence
region (a <a
href="../classes/Ensembl/Core/SeqRegion.html">Ensembl::Core::SeqRegion</a>
object). The strand of the slice represents its orientation relative to the
default orientation of the sequence region. By convention the start of the
slice is always less than the end, and does not vary with its strandedness.
Most slices you will encounter will have a strand of 1, and this is what we
will consider in our examples. It is legal to create a slice which extends
past the boundaries of a sequence region.
</p>
<h2>Coordinate Systems, Sequence Regions and Slices</h2>
<p>
Sequences stored in <a href="../classes/Ensembl.html">Ensembl</a> are
associated with coordinate systems. What the coordinate systems are varies
from species to species. For example, the homo_sapiens database has the
following coordinate systems: contig, clone, supercontig, chromosome.
Sequence and features may be retrieved from any coordinate system despite
the fact they are only stored internally in a single coordinate system. The
database stores the relationship between these coordinate systems and the
API provides means to convert between them. The API has a <a
href="../classes/Ensembl/Core/CoordSystem.html">Ensembl::Core::CoordSystem</a>
object and object adaptor, however, these are most often used internally.
The following example fetches a chromosome coordinate system object from
the database:
</p>
<pre>
  chr_coord_system = CoordSystem.find_by_name('chromosome')
  puts &quot;Coordinate system: &quot; + chr_coord_system.name + &quot;:&quot; + chr_coord_system.version
</pre>
<p>
A coordinate system is uniquely defined by its name and version. Most
coordinate systems do not have a version, and the ones that do have a
default version, so it is usually sufficient to use only the name when
requesting a coordinate system. For example, chromosome coordinate systems
have a version which is the assembly that defined the construction of the
coordinate system. The version of the human chromosome coordinate system
might be something like NCBI35 or NCBI36, depending on the version of the
Core databases used.
</p>
<p>
<a
href="../classes/Ensembl/Core/SeqRegion.html">Ensembl::Core::SeqRegion</a>
objects have an associated <a
href="../classes/Ensembl/Core/CoordSystem.html">Ensembl::Core::CoordSystem</a>
object and a name method that returns its name which uniquely defines them.
You may have noticed that the coordinate system of the sequence region was
specified when obtaining a slice in the fetch_by_region method. Similarly
the version may also be specified (though it can almost always be omitted):
</p>
<pre>
  slice = Slice.fetch_by_region('chromosome', 'X', 1000000, 10000000, 'NCBI36')
</pre>
<p>
To obtain all sequence regions for a given coordinate system, just call the
Ensembl::Core::CoordSystem#seq_regions method.
</p>
<pre>
  coord_system = CoordSystem.find_by_name('chromosome')
  chromomsomes = coord_system.seq_regions
  chromosomes.each do |chr|
    puts chr.name
  end
</pre>
<p>
Sometimes it is useful to obtain full slices of every sequence region in a
given coordinate system; this may be done using the Slice#fetch_all method:
</p>
<pre>
  chromosomes = Slice.fetch_all('chromosome')
  clones = Slice.fetch_all('clone')
</pre>
<p>
Now suppose that you wish to write code which is independent of the species
used. Not all species have the same coordinate systems; the available
coordinate systems depends on the style of assembly used for that species
(WGS, clone-based, etc.). You can obtain the list of available coordinate
systems for a species using the Ensembl::Core::CoordSystem#find(:all)
method and there is also a special pseudo-coordinate system named toplevel.
The toplevel coordinate system is not a real coordinate system, but is used
to refer to the highest level coordinate system in a given region. The
toplevel coordinate system is particularly useful in genomes that are
incompletely assembled. For example, the latest zebrafish genome consists
of a set of assembled chromosomes, and a set of supercontigs that are not
part of any chromosome. In this example, the toplevel coordinate system
sometimes refers to the chromosome coordinate system and sometimes to the
supercontig coordinate system depending on the region it is used in.
</p>
<ul>
<li>List all coordinate systems in this database:

<pre>
  coord_systems = CoordSystem.find(:all)
  coord_systems.each do |coord_system|
    puts coord_system.name + &quot;\t&quot; + coord_system.version
  end
</pre>
</li>
<li>Get all slices on the highest coordinate system:

<pre>
  slices = Slice.fetch_all('top_level')
</pre>
</li>
</ul>
<h2>Transform</h2>
<p>
Features on a seq_region in a given coordinate system may be moved to
another coordinate system. This is useful if you are working with a
particular coordinate system but you are interested in obtaining the
features coordinates in another coordinate system.
</p>
<p>
TheEnsembl::Core::Sliceable#transform method (available to all features)
can be used to move a feature to any coordinate system which is in the
database. The feature will be a clone of the original feature, but with a
different seq_region associated with it, as well as seq_region_start,
seq_region_end and seq_region_strand.
</p>
<pre>
  #Suppose original_feature is on the 'chromosome' coordinate system
  new_feature = original_feature.transform('clone')
  if new_feature.nil?
    puts &quot;Feature is not defined in clonal coordinate system&quot;
  else
    puts &quot;Feature's clonal position:&quot;
    puts new_feature.seq_region.name
    puts new_feature.seq_region_start.to_s + &quot;..&quot; + new_feature_seq_region_end
  end
</pre>
<p>
To print out the position of a feature (i.e. concatenating the seq_region
name, start, end), it&#8216;s easier to create a slice of it first, and
then calling the Ensembl::Core::Slice#display_name method:
</p>
<pre>
  puts new_feature.slice.display_name
</pre>
<p>
The transform method returns a copy of the original feature in the new
coordinate system, or nil if the feature is not defined in that coordinate
system. A feature is considered to be undefined in a coordinate system if
it overlaps an undefined region or if it crosses a coordinate system
boundary. Take for example the tiling path relationship between chromosome
and contig coordinate systems:
</p>
<pre>
                    |~~~~~~~| (Feature A) |~~~~| (Feature B)

  (ctg 1) [=============]
          (ctg 2) (------==========] (ctg 2)
                        (ctg 3)   (--============] (ctg3)
</pre>
<p>
Both Feature A and Feature B are defined in the chromosomal coordinate
system described by the tiling path of contigs. However, Feature A is not
defined in the contig coordinate system because it spans both Contig 1 and
Contig 2. Feature B, on the other hand, is still defined in the contig
coordinate system.
</p>
<p>
The special toplevel coordinate system can also be used in this instance to
move the feature to the highest possible coordinate system in a given
region:
</p>
<pre>
  new_feature = original_feature.transform('toplevel')
  puts new_feature.slice.display_name
</pre>
<p>
<b>NOTE</b>: In contrast to the perl API, there is no transfer method.
</p>
<h2>Project</h2>
<p>
When moving features between coordinate systems it is usually sufficient to
use the Ensembl::Core::Sliceable#transform method. Sometimes, however, it
is necessary to obtain coordinates in a another coordinate system even when
a coordinate system boundary is crossed. Even though the feature is
considered to be undefined in this case, the feature&#8216;s coordinates
can still be obtained in the requested coordinate system using the
Slice#project method.
</p>
<p>
While transform is a method only available to features, both slices and
features have their own project methods, which take the same arguments and
have the same return values. The project method takes a coordinate system
name as an argument and returns an array of Slice and Gap objects. The
following example illustrates the use of the project method on a slice. The
project method on a feature can be used in the same way. As with the
feature transform method the pseudo coordinate system toplevel can be used
to indicate you wish to project to the highest possible level.
</p>
<pre>
  original_slice = Slice.fetch_by_region('chromosome', '4', 329500, 380000)
  target_slices = @source_slice_contigs_with_strand.project('contig')
  target_slices.each do |ts|
    puts ts.display_name
  end
</pre>
<p>
The above returns (for Bos taurus):
</p>
<pre>
  contig::AAFC03092598:60948:61145:1
  contig::AAFC03118261:25411:37082:1
  contig::AAFC03092594:1:3622:-1
  contig:gap:50
  contig::AAFC03092597:820:35709:-1
  contig::AAFC03032210:13347:13415:1
</pre>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>